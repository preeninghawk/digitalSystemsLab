`timescale 1ns/1ps

//============================================================
// 1) Basic building blocks (DFF and N-bit register)
//============================================================

module dff(
    input  clk,
    input  reset,
    input  d,
    output reg q
);
    always @(posedge clk or posedge reset) begin
        if (reset)
            q <= 1'b0;
        else
            q <= d;
    end
endmodule

module regN #(parameter N = 8)(
    input              clk,
    input              reset,
    input      [N-1:0] d,
    output     [N-1:0] q
);
    genvar i;
    generate
        for (i = 0; i < N; i = i + 1) begin : gen_dff
            dff u_dff (
                .clk(clk),
                .reset(reset),
                .d(d[i]),
                .q(q[i])
            );
        end
    endgenerate
endmodule

//============================================================
// 2) Datapath blocks: multiplier + adder
//============================================================

module mult8(
    input  [7:0] a,
    input  [7:0] b,
    output [15:0] p
);
    assign p = a * b;
endmodule

module add8(
    input  [7:0] a,
    input  [7:0] b,
    output [7:0] s
);
    assign s = a + b;   // low 8 bits automatically kept
endmodule

//============================================================
// 3) Dot-product computation module
//    - Computes sum_{i=0..7} (x_i * w_i) mod 256
//    - Sequential: 1 multiply-accumulate per clock
//============================================================

module dotprod_compute(
    input         clk,
    input         reset,
    input         start,      // pulse to start computation
    input  [7:0]  x_in,       // X[i] from memory
    input  [7:0]  w_in,       // W[i] from memory
    output [2:0]  addr,       // address for memory (0..7)
    output [7:0]  result,     // final 8-bit result
    output        done        // pulses high for 1 cycle when finished
);
    // State encoding
    localparam S_IDLE = 2'd0;
    localparam S_RUN  = 2'd1;
    localparam S_DONE = 2'd2;

    // Registered state / index / sum
    wire [1:0] state_q;
    wire [1:0] state_d;
    wire [2:0] idx_q;
    wire [2:0] idx_d;
    wire [7:0] sum_q;
    wire [7:0] sum_d;

    // Structural registers
    regN #(.N(2)) u_state (.clk(clk), .reset(reset), .d(state_d), .q(state_q));
    regN #(.N(3)) u_idx   (.clk(clk), .reset(reset), .d(idx_d),   .q(idx_q));
    regN #(.N(8)) u_sum   (.clk(clk), .reset(reset), .d(sum_d),   .q(sum_q));

    // Datapath: multiplier and adder
    wire [15:0] prod_full;
    wire [7:0]  prod_low;
    wire [7:0]  sum_next;

    mult8 u_mul (.a(x_in), .b(w_in), .p(prod_full));

    assign prod_low = prod_full[7:0];    // use lower 8 bits only
    add8  u_add (.a(sum_q), .b(prod_low), .s(sum_next));

    // Outputs
    assign result = sum_q;
    assign addr   = idx_q;

    // Next-state logic
    reg [1:0] state_next;
    reg [2:0] idx_next;
    reg [7:0] sum_next_reg;
    reg       done_reg;

    assign state_d = state_next;
    assign idx_d   = idx_next;
    assign sum_d   = sum_next_reg;
    assign done    = done_reg;

    always @* begin
        // default values: hold
        state_next   = state_q;
        idx_next     = idx_q;
        sum_next_reg = sum_q;
        done_reg     = 1'b0;

        case (state_q)
            //----------------------------------------
            S_IDLE: begin
                if (start) begin
                    sum_next_reg = 8'd0;     // clear accumulator
                    idx_next     = 3'd0;     // start from element 0
                    state_next   = S_RUN;
                end
            end

            //----------------------------------------
            S_RUN: begin
                // accumulate current element
                sum_next_reg = sum_next;

                if (idx_q == 3'd7) begin
                    // last element processed
                    state_next = S_DONE;
                end else begin
                    idx_next   = idx_q + 3'd1;
                end
            end

            //----------------------------------------
            S_DONE: begin
                // one-cycle done pulse
                done_reg   = 1'b1;
                state_next = S_IDLE;   // go back to IDLE and wait for next start
            end

            //----------------------------------------
            default: begin
                state_next   = S_IDLE;
                idx_next     = 3'd0;
                sum_next_reg = 8'd0;
                done_reg     = 1'b0;
            end
        endcase
    end

endmodule

//============================================================
// 4) HEX to 7-segment decoder (active-LOW segments)
//    seg[6:0] = {a,b,c,d,e,f,g}  (no decimal point here)
//============================================================

module hex_to_7seg(
    input  [3:0] hex,
    output reg [6:0] seg
);
    always @* begin
        case (hex)
            4'h0: seg = 7'b1000000;
            4'h1: seg = 7'b1111001;
            4'h2: seg = 7'b0100100;
            4'h3: seg = 7'b0110000;
            4'h4: seg = 7'b0011001;
            4'h5: seg = 7'b0010010;
            4'h6: seg = 7'b0000010;
            4'h7: seg = 7'b1111000;
            4'h8: seg = 7'b0000000;
            4'h9: seg = 7'b0010000;
            4'hA: seg = 7'b0001000;
            4'hB: seg = 7'b0000011;
            4'hC: seg = 7'b1000110;
            4'hD: seg = 7'b0100001;
            4'hE: seg = 7'b0000110;
            4'hF: seg = 7'b0001110;
            default: seg = 7'b1111111; // all off
        endcase
    end
endmodule


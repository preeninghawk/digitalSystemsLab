`timescale 1ns/1ps

module DisplayModule(
    input  wire        CLK,
    input  wire        RST,
    input  wire [15:0] value,
    output reg  [7:0]  an,      // digit enable (active-low)
    output reg  [7:0]  seg      // active-low segments {dp,g,f,e,d,c,b,a}
);

    reg [3:0] bcd0, bcd1, bcd2, bcd3, bcd4;   // 5 digits
    integer i;

    always @(*) begin
        // working registers: 5 digits + 16-bit input
        reg [3:0] d0, d1, d2, d3, d4;
        reg [15:0] temp;

        d0 = 0; d1 = 0; d2 = 0; d3 = 0; d4 = 0;
        temp = value;

        // Double Dabble shift algorithm (16 iterations)
        for (i = 0; i < 16; i = i + 1) begin
            // Add 3 if >= 5
            if (d0 >= 5) d0 = d0 + 3;
            if (d1 >= 5) d1 = d1 + 3;
            if (d2 >= 5) d2 = d2 + 3;
            if (d3 >= 5) d3 = d3 + 3;
            if (d4 >= 5) d4 = d4 + 3;

            // Shift left: bring in next MSB from temp
            {d4, d3, d2, d1, d0, temp} =
                {d4, d3, d2, d1, d0, temp} << 1;
        end

        // Output BCD digits
        bcd0 = d0;
        bcd1 = d1;
        bcd2 = d2;
        bcd3 = d3;
        bcd4 = d4;
    end


    reg [3:0] digit[0:7];

    always @(*) begin
        digit[0] = bcd0;   // ones
        digit[1] = bcd1;   // tens
        digit[2] = bcd2;   // hundreds
        digit[3] = bcd3;   // thousands
        digit[4] = bcd4;   // ten-thousands
        digit[5] = 4'd15;  // blank
        digit[6] = 4'd15;  // blank
        digit[7] = 4'd15;  // blank
    end

    reg [15:0] refresh;
    reg [2:0] scan;

    always @(posedge CLK) begin
        if (RST) begin
            refresh <= 0;
            scan <= 0;
        end else begin
            refresh <= refresh + 1;
            if (refresh == 0)
                scan <= scan + 1;
        end
    end

    function [7:0] seg_encode(input [3:0] d);
        begin
            case(d)
                4'd0: seg_encode = 8'b11000000;
                4'd1: seg_encode = 8'b11111001;
                4'd2: seg_encode = 8'b10100100;
                4'd3: seg_encode = 8'b10110000;
                4'd4: seg_encode = 8'b10011001;
                4'd5: seg_encode = 8'b10010010;
                4'd6: seg_encode = 8'b10000010;
                4'd7: seg_encode = 8'b11111000;
                4'd8: seg_encode = 8'b10000000;
                4'd9: seg_encode = 8'b10010000;
                default: seg_encode = 8'b11111111;  // blank
            endcase
        end
    endfunction


    always @(posedge CLK) begin
        if (RST) begin
            an  <= 8'b11111111;
            seg <= 8'b11111111;
        end else begin
            an <= 8'b11111111;       // all digits OFF by default
            an[scan] <= 1'b0;        // turn ON selected digit
            seg <= seg_encode(digit[scan]);
        end
    end

endmodule
